use anyhow::Result;
use log::{debug, info, warn};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::future;
use zbus::{fdo::IntrospectableProxy, ConnectionBuilder};

// use crate::ledger::Ledger; // reserved for future action logging via DBus
use crate::fuse::{self, InterfaceBinding};
use crate::ledger::BlockchainLedger;
use crate::nm_query;
use crate::ovs_flows::OvsFlowManager;
// use std::path::PathBuf; // reserved for future file parameterization

pub struct AppState {
    pub bridge: String,
    pub ledger_path: String,
    pub flow_manager: OvsFlowManager,
}
pub struct PortAgent {
    state: AppState,
}

impl PortAgent {
    pub fn new(state: AppState) -> Self {
        Self { state }
    }
}

#[zbus::dbus_interface(name = "dev.ovs.PortAgent1")]
impl PortAgent {
    fn ping(&self) -> String {
        "pong".into()
    }

    fn list_ports(&self) -> zbus::fdo::Result<Vec<String>> {
        nm_query::list_connection_names()
            .map(|v| {
                v.into_iter()
                    .filter(|n| n.starts_with("ovs-eth-"))
                    .map(|n| n.trim_start_matches("ovs-eth-").to_string())
                    .collect()
            })
            .map_err(|e| zbus::fdo::Error::Failed(format!("{}", e)))
    }

    fn add_port(&self, name: &str) -> zbus::fdo::Result<String> {
        let config = crate::netlink::InterfaceConfig::new(
            self.state.bridge.clone(),
            name.to_string(),
            name.to_string(),
            0, // vmid
        )
        .with_ledger_path(self.state.ledger_path.clone());

        tokio::runtime::Handle::current()
            .block_on(async { crate::netlink::create_container_interface(config).await })
            .map_err(|e| {
                zbus::fdo::Error::Failed(format!("Failed to create container interface: {}", e))
            })?;

        Ok(format!("Container interface created for {}", name))
    }

    fn del_port(&self, name: &str) -> zbus::fdo::Result<String> {
        let interfaces_path = "/etc/network/interfaces".to_string();
        let managed_tag = "ovs-port-agent".to_string();
        let bridge = self.state.bridge.clone();
        let ledger_path = self.state.ledger_path.clone();

        tokio::runtime::Handle::current()
            .block_on(async {
                crate::netlink::remove_container_interface(
                    bridge,
                    name,
                    interfaces_path,
                    managed_tag,
                    ledger_path,
                )
                .await
            })
            .map_err(|e| {
                zbus::fdo::Error::Failed(format!("Failed to remove container interface: {}", e))
            })?;

        Ok(format!("Container interface {} removed", name))
    }

    fn introspect_systemd_networkd(&self) -> zbus::fdo::Result<String> {
        match tokio::runtime::Handle::current()
            .block_on(async { introspect_systemd_networkd().await })
        {
            Ok(_) => Ok("systemd-networkd introspection completed successfully".to_string()),
            Err(e) => Err(zbus::fdo::Error::Failed(format!(
                "NetworkManager introspection failed: {}",
                e
            ))),
        }
    }

    /// Get comprehensive system network state
    fn get_system_network_state(&self) -> zbus::fdo::Result<String> {
        let state = tokio::runtime::Handle::current()
            .block_on(async { crate::systemd_dbus::get_comprehensive_network_state().await })
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to get network state: {}", e)))?;

        Ok(serde_json::to_string_pretty(&state)
            .unwrap_or_else(|_| "Failed to serialize network state".to_string()))
    }

    /// Validate bridge connectivity and synchronization
    fn validate_bridge_connectivity(&self, bridge: &str) -> zbus::fdo::Result<String> {
        let validation = tokio::runtime::Handle::current()
            .block_on(async { validate_bridge_connectivity(bridge).await })
            .map_err(|e| zbus::fdo::Error::Failed(format!("Bridge validation failed: {}", e)))?;

        Ok(serde_json::to_string_pretty(&validation)
            .unwrap_or_else(|_| "Failed to serialize validation results".to_string()))
    }

    /// Get interface bindings for Proxmox integration
    fn get_interface_bindings(&self) -> zbus::fdo::Result<String> {
        let bindings = fuse::get_interface_bindings()
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to get bindings: {}", e)))?;

        Ok(serde_json::to_string_pretty(&bindings)
            .unwrap_or_else(|_| "Failed to serialize bindings".to_string()))
    }

    /// Perform atomic bridge operation with enhanced safety
    fn atomic_bridge_operation(&self, bridge: &str, operation: &str) -> zbus::fdo::Result<String> {
        let result = tokio::runtime::Handle::current()
            .block_on(async { perform_atomic_bridge_operation(bridge, operation).await })
            .map_err(|e| zbus::fdo::Error::Failed(format!("Atomic operation failed: {}", e)))?;

        Ok(result)
    }

    /// Get OVS bridge topology and state
    fn get_bridge_topology(&self, bridge: &str) -> zbus::fdo::Result<String> {
        let topology = tokio::runtime::Handle::current()
            .block_on(async { get_bridge_topology(bridge).await })
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to get topology: {}", e)))?;

        Ok(serde_json::to_string_pretty(&topology)
            .unwrap_or_else(|_| "Failed to serialize topology".to_string()))
    }

    /// Get blockchain ledger statistics
    fn get_blockchain_stats(&self) -> zbus::fdo::Result<String> {
        let ledger = tokio::runtime::Handle::current()
            .block_on(async { BlockchainLedger::new(self.state.ledger_path.clone().into()) })
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to open ledger: {}", e)))?;

        let stats = ledger
            .get_stats()
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to get stats: {}", e)))?;

        Ok(serde_json::to_string_pretty(&stats)
            .unwrap_or_else(|_| "Failed to serialize blockchain stats".to_string()))
    }

    /// Get blockchain blocks by category
    fn get_blocks_by_category(&self, category: &str) -> zbus::fdo::Result<String> {
        let ledger = tokio::runtime::Handle::current()
            .block_on(async { BlockchainLedger::new(self.state.ledger_path.clone().into()) })
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to open ledger: {}", e)))?;

        let blocks = ledger
            .get_blocks_by_category(category)
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to get blocks: {}", e)))?;

        Ok(serde_json::to_string_pretty(&blocks)
            .unwrap_or_else(|_| "Failed to serialize blocks".to_string()))
    }

    /// Get blockchain blocks by height range
    fn get_blocks_by_height(&self, start: u64, end: u64) -> zbus::fdo::Result<String> {
        let ledger = tokio::runtime::Handle::current()
            .block_on(async { BlockchainLedger::new(self.state.ledger_path.clone().into()) })
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to open ledger: {}", e)))?;

        let blocks = ledger
            .get_blocks_by_height(start, end)
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to get blocks: {}", e)))?;

        Ok(serde_json::to_string_pretty(&blocks)
            .unwrap_or_else(|_| "Failed to serialize blocks".to_string()))
    }

    /// Verify blockchain integrity
    fn verify_blockchain_integrity(&self) -> zbus::fdo::Result<String> {
        let ledger = tokio::runtime::Handle::current()
            .block_on(async { BlockchainLedger::new(self.state.ledger_path.clone().into()) })
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to open ledger: {}", e)))?;

        let is_valid = ledger
            .verify_chain()
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to verify chain: {}", e)))?;

        Ok(if is_valid {
            "Blockchain integrity: VALID".to_string()
        } else {
            "Blockchain integrity: INVALID".to_string()
        })
    }

    /// Add data to blockchain through D-Bus
    fn add_blockchain_data(
        &self,
        category: &str,
        action: &str,
        data: &str,
    ) -> zbus::fdo::Result<String> {
        let data_value = serde_json::from_str(data)
            .map_err(|e| zbus::fdo::Error::Failed(format!("Invalid JSON data: {}", e)))?;

        let mut ledger = tokio::runtime::Handle::current()
            .block_on(async { BlockchainLedger::new(self.state.ledger_path.clone().into()) })
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to open ledger: {}", e)))?;

        let block_hash = ledger
            .add_data(category, action, data_value)
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to add data: {}", e)))?;

        Ok(format!(
            "Data added to blockchain with hash: {}",
            block_hash
        ))
    }

    /// Get specific block by hash
    fn get_block_by_hash(&self, hash: &str) -> zbus::fdo::Result<String> {
        let ledger = tokio::runtime::Handle::current()
            .block_on(async { BlockchainLedger::new(self.state.ledger_path.clone().into()) })
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to open ledger: {}", e)))?;

        let block = ledger
            .get_block(hash)
            .map_err(|e| zbus::fdo::Error::Failed(format!("Failed to get block: {}", e)))?;

        match block {
            Some(b) => Ok(serde_json::to_string_pretty(&b)
                .unwrap_or_else(|_| "Failed to serialize block".to_string())),
            None => Ok("Block not found".to_string()),
        }
    }
    /// Clear all OVS flow rules
    fn clear_flows(&self) -> zbus::fdo::Result<String> {
        match self.state.flow_manager.clear_all_flows() {
            Ok(_) => Ok("All OVS flows cleared successfully".to_string()),
            Err(e) => Err(zbus::fdo::Error::Failed(format!(
                "Failed to clear flows: {}",
                e
            ))),
        }
    }

    /// Setup container-specific routing
    fn setup_container_routing(
        &self,
        container_ip: &str,
        container_port: &str,
        register_id: u32,
    ) -> zbus::fdo::Result<String> {
        match self.state.flow_manager.setup_container_routing(
            container_ip,
            container_port,
            register_id,
        ) {
            Ok(_) => Ok(format!(
                "Container routing setup for {} via register {}",
                container_ip, register_id
            )),
            Err(e) => Err(zbus::fdo::Error::Failed(format!(
                "Failed to setup container routing: {}",
                e
            ))),
        }
    }

    /// Setup application-aware routing
    fn setup_application_routing(&self, output_port: &str) -> zbus::fdo::Result<String> {
        match self
            .state
            .flow_manager
            .setup_application_routing(output_port)
        {
            Ok(_) => Ok("Application-aware routing setup successfully".to_string()),
            Err(e) => Err(zbus::fdo::Error::Failed(format!(
                "Failed to setup application routing: {}",
                e
            ))),
        }
    }

    /// Setup basic container network routing
    fn setup_basic_routing(
        &self,
        container_network: &str,
        physical_interface: &str,
        internal_port: &str,
    ) -> zbus::fdo::Result<String> {
        match self.state.flow_manager.setup_basic_routing(
            container_network,
            physical_interface,
            internal_port,
        ) {
            Ok(_) => Ok(format!(
                "Basic routing setup for container network {}",
                container_network
            )),
            Err(e) => Err(zbus::fdo::Error::Failed(format!(
                "Failed to setup basic routing: {}",
                e
            ))),
        }
    }

    /// Dump current flow rules
    fn dump_flows(&self) -> zbus::fdo::Result<String> {
        match self.state.flow_manager.dump_flows() {
            Ok(flows) => Ok(flows),
            Err(e) => Err(zbus::fdo::Error::Failed(format!(
                "Failed to dump flows: {}",
                e
            ))),
        }
    }
}

pub async fn serve_with_state(state: AppState) -> Result<()> {
    let agent = PortAgent::new(state);
    let name = "dev.ovs.PortAgent1";
    let path = "/dev/ovs/PortAgent1";
    let _conn = ConnectionBuilder::system()?
        .name(name)?
        .serve_at(path, agent)?
        .build()
        .await?;
    info!("D-Bus service registered: {} at {}", name, path);
    future::pending::<()>().await;
    Ok(())
}

pub async fn introspect_systemd_networkd() -> Result<()> {
    info!("Performing comprehensive D-Bus introspection on systemd-networkd");
    let conn = zbus::Connection::system().await?;
    introspect_object(
        &conn,
        "org.freedesktop.network1",
        "/org/freedesktop/network1",
    )
    .await?;
    Ok(())
}

async fn introspect_object(
    conn: &zbus::Connection,
    destination: &str,
    path: &str,
) -> Result<String> {
    match IntrospectableProxy::builder(conn)
        .destination(destination)?
        .path(path)?
        .build()
        .await
    {
        Ok(proxy) => match proxy.introspect().await {
            Ok(xml) => Ok(xml),
            Err(e) => Err(anyhow::anyhow!("Failed to introspect {}: {}", path, e)),
        },
        Err(e) => Err(anyhow::anyhow!(
            "Failed to create proxy for {}: {}",
            path,
            e
        )),
    }
}

/// Comprehensive network state for system-wide control
#[derive(Debug, Serialize, Deserialize)]
#[allow(dead_code)]
pub struct NetworkState {
    pub networkmanager: NetworkManagerState,
    pub ovs_bridges: Vec<OVSBridgeState>,
    pub interface_bindings: std::collections::HashMap<String, InterfaceBinding>,
    pub connectivity_status: ConnectivityStatus,
    pub timestamp: String,
}

#[derive(Debug, Serialize, Deserialize)]
#[allow(dead_code)]
pub struct NetworkManagerState {
    pub version: String,
    pub state: String,
    pub connectivity: String,
    pub active_connections: u32,
    pub total_connections: u32,
    pub devices: u32,
}

#[derive(Debug, Serialize, Deserialize)]
#[allow(dead_code)]
pub struct OVSBridgeState {
    pub name: String,
    pub ports: Vec<String>,
    pub interfaces: Vec<String>,
    pub active: bool,
    pub datapath_type: String,
}

#[derive(Debug, Serialize, Deserialize)]
#[allow(dead_code)]
pub struct ConnectivityStatus {
    pub internet_reachable: bool,
    pub dns_working: bool,
    pub default_route: String,
    pub uplink_status: String,
}

#[allow(dead_code)]
async fn get_comprehensive_network_state() -> Result<NetworkState> {
    let mut nm_state = NetworkManagerState {
        version: "unknown".to_string(),
        state: "unknown".to_string(),
        connectivity: "unknown".to_string(),
        active_connections: 0,
        total_connections: 0,
        devices: 0,
    };

    // Get NetworkManager state via nmcli
    if let Ok(output) = tokio::process::Command::new("networkctl")
        .args(["--version"])
        .output()
        .await
    {
        if let Ok(version) = String::from_utf8(output.stdout) {
            nm_state.version = version.trim().to_string();
        }
    }

    if let Ok(output) = tokio::process::Command::new("networkctl")
        .args(["-t", "-f", "STATE", "general"])
        .output()
        .await
    {
        if let Ok(state) = String::from_utf8(output.stdout) {
            nm_state.state = state.trim().to_string();
        }
    }

    if let Ok(output) = tokio::process::Command::new("networkctl")
        .args(["-t", "-f", "CONNECTIVITY", "general"])
        .output()
        .await
    {
        if let Ok(connectivity) = String::from_utf8(output.stdout) {
            nm_state.connectivity = connectivity.trim().to_string();
        }
    }

    if let Ok(output) = tokio::process::Command::new("networkctl")
        .args(["list", "--no-pager"])
        .output()
        .await
    {
        let count = String::from_utf8_lossy(&output.stdout).lines().count();
        nm_state.active_connections = count as u32;
    }

    if let Ok(output) = tokio::process::Command::new("networkctl")
        .args(["-t", "-f", "NAME", "connection", "show"])
        .output()
        .await
    {
        let count = String::from_utf8_lossy(&output.stdout).lines().count();
        nm_state.total_connections = count as u32;
    }

    if let Ok(output) = tokio::process::Command::new("networkctl")
        .args(["-t", "device", "status"])
        .output()
        .await
    {
        let count = String::from_utf8_lossy(&output.stdout).lines().count();
        nm_state.devices = count as u32;
    }

    // Get OVS bridge states
    let ovs_bridges = get_ovs_bridge_states().await?;

    // Get interface bindings
    let interface_bindings = fuse::get_interface_bindings()?;

    // Get connectivity status
    let connectivity_status = get_connectivity_status().await?;

    Ok(NetworkState {
        networkmanager: nm_state,
        ovs_bridges,
        interface_bindings,
        connectivity_status,
        timestamp: chrono::Utc::now().to_rfc3339(),
    })
}

#[allow(dead_code)]
async fn get_ovs_bridge_states() -> Result<Vec<OVSBridgeState>> {
    let mut bridges = Vec::new();

    if let Ok(output) = tokio::process::Command::new("ovs-vsctl")
        .args(["list-br"])
        .output()
        .await
    {
        let bridge_names = String::from_utf8_lossy(&output.stdout);

        for bridge_name in bridge_names.lines() {
            let bridge_name = bridge_name.trim();
            if bridge_name.is_empty() {
                continue;
            }

            let mut bridge_state = OVSBridgeState {
                name: bridge_name.to_string(),
                ports: Vec::new(),
                interfaces: Vec::new(),
                active: false,
                datapath_type: "system".to_string(),
            };

            // Get ports for this bridge
            if let Ok(output) = tokio::process::Command::new("ovs-vsctl")
                .args(["list-ports", bridge_name])
                .output()
                .await
            {
                let ports = String::from_utf8_lossy(&output.stdout);
                bridge_state.ports = ports
                    .lines()
                    .filter(|p| !p.trim().is_empty())
                    .map(|p| p.trim().to_string())
                    .collect();
            }

            // Get interfaces for this bridge
            if let Ok(output) = tokio::process::Command::new("ovs-vsctl")
                .args(["list-ifaces", bridge_name])
                .output()
                .await
            {
                let interfaces = String::from_utf8_lossy(&output.stdout);
                bridge_state.interfaces = interfaces
                    .lines()
                    .filter(|i| !i.trim().is_empty())
                    .map(|i| i.trim().to_string())
                    .collect();
            }

            // Check if bridge is active (has NetworkManager connection)
            if let Ok(output) = tokio::process::Command::new("networkctl")
                .args(["-t", "-f", "NAME,STATE", "connection", "show"])
                .output()
                .await
            {
                let connections = String::from_utf8_lossy(&output.stdout);
                for line in connections.lines() {
                    let parts: Vec<&str> = line.split(':').collect();
                    if parts.len() >= 2 && parts[0] == bridge_name {
                        bridge_state.active = parts[1].contains("activated");
                        break;
                    }
                }
            }

            bridges.push(bridge_state);
        }
    }

    Ok(bridges)
}

#[allow(dead_code)]
async fn get_connectivity_status() -> Result<ConnectivityStatus> {
    let mut status = ConnectivityStatus {
        internet_reachable: false,
        dns_working: false,
        default_route: "unknown".to_string(),
        uplink_status: "unknown".to_string(),
    };

    // Check internet connectivity
    if let Ok(output) = tokio::process::Command::new("ping")
        .args(["-c", "1", "-W", "2", "8.8.8.8"])
        .output()
        .await
    {
        status.internet_reachable = output.status.success();
    }

    // Check DNS
    if let Ok(output) = tokio::process::Command::new("nslookup")
        .args(["google.com"])
        .output()
        .await
    {
        status.dns_working = output.status.success();
    }

    // Get default route
    if let Ok(output) = tokio::process::Command::new("ip")
        .args(["route", "show", "default"])
        .output()
        .await
    {
        let route_info = String::from_utf8_lossy(&output.stdout);
        status.default_route = route_info.trim().to_string();
    }

    // Get uplink status (first non-lo interface)
    if let Ok(output) = tokio::process::Command::new("networkctl")
        .args(["-t", "-f", "DEVICE,STATE", "device", "status"])
        .output()
        .await
    {
        let devices = String::from_utf8_lossy(&output.stdout);
        for line in devices.lines() {
            let parts: Vec<&str> = line.split(':').collect();
            if parts.len() >= 2 && parts[0] != "lo" {
                status.uplink_status = parts[1].to_string();
                break;
            }
        }
    }

    Ok(status)
}

async fn validate_bridge_connectivity(bridge: &str) -> Result<serde_json::Value> {
    let mut validation = serde_json::Map::new();

    // Validate OVS bridge exists
    let ovs_exists = tokio::process::Command::new("ovs-vsctl")
        .args(["br-exists", bridge])
        .output()
        .await
        .map(|output| output.status.success())
        .unwrap_or(false);

    validation.insert("ovs_bridge_exists".to_string(), json!(ovs_exists));

    // Validate systemd-networkd configuration exists
    let systemd_exists = tokio::process::Command::new("networkctl")
        .args(["status", bridge, "--no-pager"])
        .output()
        .await
        .map(|output| output.status.success())
        .unwrap_or(false);

    validation.insert("systemd_network_exists".to_string(), json!(systemd_exists));

    // Validate bridge is active
    let bridge_active = tokio::process::Command::new("networkctl")
        .args(["status", bridge, "--no-pager"])
        .output()
        .await
        .map(|output| {
            let state = String::from_utf8_lossy(&output.stdout);
            state.trim().ends_with("activated")
        })
        .unwrap_or(false);

    validation.insert("bridge_active".to_string(), json!(bridge_active));

    // Validate bridge synchronization with FUSE bindings
    let sync_validation = fuse::validate_bridge_synchronization(bridge)?;
    validation.insert("bridge_synchronization".to_string(), json!(sync_validation));

    // Validate connectivity preservation
    let connectivity_preserved = validate_connectivity_preservation().await?;
    validation.insert(
        "connectivity_preserved".to_string(),
        json!(connectivity_preserved),
    );

    Ok(serde_json::Value::Object(validation))
}

async fn validate_connectivity_preservation() -> Result<bool> {
    // Check if we can reach essential services
    let mut essential_checks = Vec::new();

    // Check DNS
    if let Ok(result) = tokio::process::Command::new("nslookup")
        .args(["localhost"])
        .output()
        .await
    {
        essential_checks.push(result.status.success());
    }

    // Check if systemd-networkd is responsive
    if let Ok(result) = tokio::process::Command::new("networkctl")
        .args(["status"])
        .output()
        .await
    {
        essential_checks.push(result.status.success());
    }

    // Check if we have active connections
    if let Ok(output) = tokio::process::Command::new("networkctl")
        .args(["list", "--no-pager"])
        .output()
        .await
    {
        let active_count = String::from_utf8_lossy(&output.stdout).lines().count();
        essential_checks.push(active_count > 0);
    }

    // All checks must pass for connectivity to be preserved
    Ok(essential_checks.iter().all(|&check| check))
}

async fn perform_atomic_bridge_operation(bridge: &str, operation: &str) -> Result<String> {
    debug!(
        "Performing atomic bridge operation: {} on {}",
        operation, bridge
    );

    match operation {
        "create_checkpoint" => {
            // Create systemd-networkd configuration backup
            let checkpoint_path = create_systemd_backup().await?;
            Ok(format!("Checkpoint created: {}", checkpoint_path))
        }
        "validate_topology" => {
            // Validate complete bridge topology
            let validation = validate_bridge_topology(bridge).await?;
            Ok(format!(
                "Topology validation: {}",
                if validation { "PASSED" } else { "FAILED" }
            ))
        }
        "sync_with_proxmox" => {
            // Synchronize bridge state with Proxmox
            let sync_result = synchronize_with_proxmox(bridge).await?;
            Ok(format!("Proxmox sync: {}", sync_result))
        }
        _ => Err(anyhow::anyhow!("Unknown atomic operation: {}", operation)),
    }
}

async fn create_systemd_backup() -> Result<String> {
    // Create a backup of current systemd network configuration
    let backup_dir = format!(
        "/tmp/systemd-network-backup-{}",
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs()
    );

    std::fs::create_dir_all(&backup_dir)?;

    // Copy all .network and .netdev files
    let network_dir = std::path::Path::new("/etc/systemd/network");
    if network_dir.exists() {
        for entry in std::fs::read_dir(network_dir)? {
            let entry = entry?;
            let path = entry.path();
            if let Some(ext) = path.extension() {
                if ext == "network" || ext == "netdev" {
                    let file_name = path.file_name().unwrap();
                    let dest = std::path::Path::new(&backup_dir).join(file_name);
                    std::fs::copy(&path, &dest)?;
                }
            }
        }
    }

    Ok(backup_dir)
}

#[allow(dead_code)]
async fn get_nm_device_paths(conn: &zbus::Connection) -> Result<Vec<String>> {
    let proxy = zbus::Proxy::new(
        conn,
        "org.freedesktop.network1",
        "/org/freedesktop/network1",
        "org.freedesktop.network1",
    )
    .await?;

    let devices: Vec<zbus::zvariant::OwnedObjectPath> = proxy.call("GetDevices", &()).await?;

    Ok(devices
        .into_iter()
        .map(|device| device.to_string())
        .collect())
}

async fn validate_bridge_topology(bridge: &str) -> Result<bool> {
    // Check OVS level
    let ovs_valid = tokio::process::Command::new("ovs-vsctl")
        .args(["br-exists", bridge])
        .output()
        .await
        .map(|output| output.status.success())
        .unwrap_or(false);

    if !ovs_valid {
        return Ok(false);
    }

    // Check NetworkManager level
    let nm_valid = tokio::process::Command::new("networkctl")
        .args(["status", bridge, "--no-pager"])
        .output()
        .await
        .map(|output| output.status.success())
        .unwrap_or(false);

    if !nm_valid {
        return Ok(false);
    }

    // Check if bridge has required ports
    let has_ports = tokio::process::Command::new("ovs-vsctl")
        .args(["list-ports", bridge])
        .output()
        .await
        .map(|output| {
            let ports = String::from_utf8_lossy(&output.stdout);
            ports.lines().any(|line| !line.trim().is_empty())
        })
        .unwrap_or(false);

    Ok(has_ports)
}

async fn synchronize_with_proxmox(bridge: &str) -> Result<String> {
    let bindings = fuse::get_interface_bindings()?;

    let mut sync_count = 0;
    for (ovs_interface, binding) in bindings.iter() {
        if binding.bridge == bridge {
            // Ensure Proxmox API compatibility
            if let Err(e) = fuse::bind_veth_interface_enhanced(
                &binding.proxmox_veth,
                ovs_interface,
                binding.vmid,
                &binding.container_id,
                bridge,
            ) {
                warn!("Failed to sync {}: {}", ovs_interface, e);
            } else {
                sync_count += 1;
            }
        }
    }

    Ok(format!(
        "Synchronized {} interfaces with Proxmox",
        sync_count
    ))
}

async fn get_bridge_topology(bridge: &str) -> Result<serde_json::Value> {
    let mut topology = serde_json::Map::new();

    // OVS bridge information
    if let Ok(output) = tokio::process::Command::new("ovs-vsctl")
        .args(["show"])
        .output()
        .await
    {
        let ovs_show = String::from_utf8_lossy(&output.stdout);
        topology.insert("ovs_show".to_string(), json!(ovs_show));
    }

    // NetworkManager connection details
    if let Ok(output) = tokio::process::Command::new("networkctl")
        .args(["status", bridge, "--no-pager"])
        .output()
        .await
    {
        let systemd_details = String::from_utf8_lossy(&output.stdout);
        topology.insert("systemd_network".to_string(), json!(systemd_details));
    }

    // Bridge ports and interfaces
    if let Ok(output) = tokio::process::Command::new("ovs-vsctl")
        .args(["list-ports", bridge])
        .output()
        .await
    {
        let ports = String::from_utf8_lossy(&output.stdout);
        topology.insert(
            "ports".to_string(),
            json!(ports
                .lines()
                .filter(|p| !p.trim().is_empty())
                .collect::<Vec<_>>()),
        );
    }

    if let Ok(output) = tokio::process::Command::new("ovs-vsctl")
        .args(["list-ifaces", bridge])
        .output()
        .await
    {
        let interfaces = String::from_utf8_lossy(&output.stdout);
        topology.insert(
            "interfaces".to_string(),
            json!(interfaces
                .lines()
                .filter(|i| !i.trim().is_empty())
                .collect::<Vec<_>>()),
        );
    }

    Ok(serde_json::Value::Object(topology))
}
